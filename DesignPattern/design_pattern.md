# Design Pattern
* 과거 이미지 중심에서 현재는 데이터 중심으로 많이 이동했다.
* 패턴은 정형화된 형태를 뜻하고 **디자인 패턴은 설계 패턴**을 뜻한다.
* 우리는 객체지향프로그래밍에서의 CLASS처럼 **결국 re-usability (재활용)하기 위한다.** 그런데, 어디까지 재사용을 할 것인가?
* 자주 반복적으로 많이 사용되는 것을 모듈화, function화, class화하면 시간을 줄일 수 있다.
* 필요한 기능 이미 많이 만들어 놨다면 바로 호출만 함으로써 빨리 구현 가능하므로 생산성이 향상되고 효율적이다.

## 재사용
1. 생산성 향상
2. 신뢰성 : 30년 동안 누가 만들고 버그를 잡은 함수라면 믿고 쓸 수 있다. (이미 검증된 함수라는 것)

* 인공위성, 로켓 등을 만들때는 신기술보다는 검증된 프로세스들을 많이 쓴다. 이는 **성능, 자원의 효율성 보다는 생산성, 신뢰성이 강조된다.**
* 코드를 만드는 과정도 중요하지만 **정말 중요한 단계를 뽑으라면, 설계 과정이다.**
* 설계 과정에 재사용을 대입한다면 **누군가는 이미 이러한 SW를 만들어보지 않았을까? 그들은 무슨 고민, 어떤 형태로 그것을 짰을까?**
	* 대부분 비슷한 유형의 SW 짰을 것이기에 그들의 생각과 설계를 재사용 해 보자!
	* SW의 유형별 패턴이 있을 테니 그걸 보고 고민해서 생산성과 신뢰성을 향상시켜 보자
	* 소스코드는 입력 파라미터로 출력 파라미터 코드를 가져오는 것이므로 바로 쓸 수 있으나 _디자인은 주어지는 조건들이 같기가 힘들다._ (메모리, 고객, 시대 등 다 다르다.)
* Best 1 이 Only 1이 되는 것은 아니다. 남이 해놓은 것은 참조 하여 내가 잘 짜자!
* **미리 해본 사람들의 조언으로 디자인 패턴의 장점, 단점 등을 알 수 있는 게 디자인 패턴의 장점이자 목적**이다.

#### Objected oriented design pattern
* 객체지향을 지원하지 않는 언어에서는 안 돌아갈 수도 있다.
* 반대로 이미 언어에 구현 다 되어 있을 수도 있다. class에 데이터와 메소드 함수를 묶어둠.

#### Caution
* **디자인패턴이 프로그래밍 언어와 매칭할 때는 고민을 해야 한다.**
	* 그 언어가 디자인패턴을 반영하지 못 할 수 도 있기 때문에 프로그래밍 언어가 그 디자인패턴을 받아들일 수 있는지 생각해 봐야한다.
	* 디자인하는 사람이 개발하는 사람과 다르기 때문에 디자인은 개발과 독립적일 수 있다. 
* **디자인 패턴은 실질적으로 개발 단계를 고민하고 같이 생각해야될 문제**
	* 디자인과 디자인 패턴은 다르다.
	* 개발과 운영 / 디자인과 개발 / 클라이언트와 서버의 벽이 무너지고 있다.
	* 따라서 다른 분야의 영역도 충분히 이해하고 알아야 된다.



## 1. Adapter Pattern (UMLs)
* 클라이언트- 요청하고자 하는 쪽 30년된 소프트웨어와 클라이언트의 요구사항이 다르다면? But SW를 고치지 않겠다고 한다면?
* 타켓과 어뎁티 사이에서 타입이 다르면 타입을 맞춰주고, 개수가 다르면 개수를 맞춰준다. `220V -> (adapter SW) -> 5V`
* **client (operations 호출)- > target (내가 만든 것, client 호출 받음) -> adapter (요청을 adaptee 형태로 바꿔주기 위해 변환 작업을 해줌, 빠진것 넣고 타입 바꾸기 등) -> adaptee (Specific request 호출됨)**


### UML (Unified Modeling Language) 
* 통합모델링언어
* 개발자간의 의사소통을 원활하게 하기 위해 표준화한 모델링 언어
* 요구분석, 시스템설계, 시스템 구현 등의 시스템 개발 과정에서, 개발자간의 의사소통을 원활하게 이루어지게 하기 위하여 표준화한 모델링 언어이다. 
* has, is, owns, uses, realizes... 등 화살표마다 뜻이 모두 다름


## 2. Facade Pattern
* **Facade: 뒷쪽의 소프트웨어가 수십년이 지나서 바껴도, 실제 유저(클라이언트)입장에서는 인터페이스가 바뀌지 않는다!**
* 사용하는 입장에서는 쉽고 함구적으로 유지할 수 있고 갯수가 줄어들길 바라는 것이 파사드 이용하는 이유다.
* 내부의 구조 외부에 표출 안되도록 최대한 단순화되어있어야 한다. 
* 사용자들은 사용 및 이해하기 쉽고 안정적이다.
* 사용하는 사람들이 많은 소프트웨어라면 더욱 큰 장점을 가질 수 있을 것이다.
* python 으로 파일럿 서비스하고, 상용으로 넘어가기 전에 API를 다듬을 때 파사드 API 쌓고, 일부를 GO 등으로 바꿔갈 수도 있음
* **성능보다 얼마나 생산적으로 할 것인가? 얼마나 안정적인가? 를 생각해야 된다. 얼마나 빨라지고 얼마나 적은 메모리를 쓰는가는 중요하지 않다.**


## 3. Decorator Pattern
* 내가 클래스로 부터 오브젝트를 만들었는데, 프로그램 실행 중에 기능이 추가되어서 확장되거나 동적으로 기능이 제거되는 것



## Design Pattern of GoF
* 소프트웨어개발방법은 세부적인 것은 바뀌지만, 전체 큰틀은 공통된 부분이 있다. 
* _**개발 전과정에서 간접적 경험을 통해 우리가 재활용 할 수 있는 부분은 충분히 재활용해야 되지 않을까?**_
* 디자인 패턴의 예시, 종류를 외우는 것보다 책을 읽고 본인이 관심있는 분야에 대해 공부하는 것이 더 중요하다.
* 디자인 패턴의 단점 및 비판도 있다.
	* **디자인패턴에 대한 가장 큰 갑론을박은 언어는 계속 발전한다는 뜻**
	* 언어가 발전하면, 그 시점에서 일반적으로 프로그래머들이 구현해야하는 웬만한 기능들은 대부분 언어가 다 흡수하고 지원하려고 하므로, **잘못쓰면 복잡도만 증가할 수 있다.**



